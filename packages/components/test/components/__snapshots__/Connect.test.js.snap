// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Testing of Connect function render dart Connect method 1`] = `
"/// Method to establish a WebSocket connection
  Future<void> connect() async {
      if (_channel != null) {
          print('Already connected to HoppscotchEchoWebSocketClient server');
          return;
      }
      try {
          final wsUrl = Uri.parse(_url);
          _channel = WebSocketChannel.connect(wsUrl);
          print('Connected to HoppscotchEchoWebSocketClient server');
          /// Listen to the incoming message stream
          _channel?.stream.listen(
          (message) {
          if (_messageHandlers.isNotEmpty) {
            for (var handler in _messageHandlers) {
              _handleMessage(message, handler);
            }
          } else {
            print('Message received: $message');
          }
        },

          onError: (error) {
          if (_errorHandlers.isNotEmpty) {
            for (var handler in _errorHandlers) {
              handler(error);
            }
          } else {
            print('WebSocket Error: $error');
          }
        },

          onDone: () {
          _channel = null;
          print('Disconnected from HoppscotchEchoWebSocketClient server');
        },

      );   
    } catch (error) {
      print('Connection failed: $error');
      rethrow;
    }
  }"
`;

exports[`Testing of Connect function render javascript Connect method 1`] = `
"// Method to establish a WebSocket connection
  connect() {
      return new Promise((resolve, reject) => {
          this.websocket = new WebSocket(this.url);
          // On successful connection
        this.websocket.onopen = () => {
        console.log('Connected to HoppscotchEchoWebSocketClient server');
        resolve();
      };

          // On receiving a message
      this.websocket.onmessage = (event) => {
        if (this.messageHandlers.length > 0) {
          // Call custom message handlers
          this.messageHandlers.forEach(handler => {
            if (typeof handler === 'function') {
              this.handleMessage(event.data, handler);
            }
          });
        } else {
          // Default message logging
          console.log('Message received:', event.data);
        }
      };

          // On error first call custom error handlers, then default error behavior
      this.websocket.onerror = (error) => {
        if (this.errorHandlers.length > 0) {
          // Call custom error handlers
          this.errorHandlers.forEach(handler => handler(error));
        } else {
          // Default error behavior
          console.error('WebSocket Error:', error);
        }
        reject(error);
      };

          // On connection close
      this.websocket.onclose = () => {
        console.log('Disconnected from HoppscotchEchoWebSocketClient server');
      };

      });
  }"
`;

exports[`Testing of Connect function render python Connect method 1`] = `
"def on_open(self, ws):
    print(\\"Connected to HoppscotchEchoWebSocketClient server\\")

  def on_message(self, ws, message):
    self.handle_message(message)

  def on_error(self, ws, error):
    print(\\"WebSocket Error:\\", error)
    self.handle_error(error)

  def on_close(self, ws, close_status_code, close_msg):
    print(\\"Disconnected from HoppscotchEchoWebSocketClient\\", close_status_code, close_msg)

  def connect(self):
      \\"\\"\\"Establish the connection and start the run_forever loop in a background thread.\\"\\"\\"
      ssl_opts = {\\"ca_certs\\": certifi.where()}
      self.ws_app = websocket.WebSocketApp(
          self.url,
          on_open=self.on_open,
          on_message=self.on_message,
          on_error=self.on_error,
          on_close=self.on_close
      )
      # Run the WebSocketApp's run_forever in a separate thread with multithreading enabled.
      def run():

          retry = 0
          max_retries = 5
        
          while not self._stop_event.is_set() and retry < max_retries:
              try:
                  retry += 1
                  print(\\"Starting WebSocket thread...\\")
                  self.ws_app.run_forever(sslopt=ssl_opts)
              except Exception as e:
                  print(f\\"Exception in WebSocket thread: {e}\\")  # Print full error details

      thread = threading.Thread(target=run, daemon=True)
      thread.start()"
`;
