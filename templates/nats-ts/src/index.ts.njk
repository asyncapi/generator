
import { Client, NatsConnectionOptions, connect, Payload, NatsError, Subscription } from 'ts-nats';

{%- for channelName, channel in asyncapi.channels() %}
import * as {{ channelName | camelCase }}Channel from "./channels/{{ channelName }}";
{%- endfor %}

{%- for messageName, message in asyncapi.allMessages() %}
import {default as {{ messageName | pascalCase }}Message} from "./messages/{{ messageName | pascalCase }}";
{%- endfor %}

export default class NatsAsyncApiClient {
  public nc?: Client;
  public options: NatsConnectionOptions;
  constructor(options : NatsConnectionOptions) {
    options = this.setDefaultOptions(options);
    this.options = options;
    this.connect(options);
  }

  /**
   * Try to connect to the NATS server.
   * @param options The connection options for NATS
   */
  private async connect(options : NatsConnectionOptions){
    try{
      this.nc = await connect(options);
    }catch(e){
      console.error("Could not connect to NATS: " + e)
    }
  }

  /**
   * Set the default options from the AsyncAPI file.
   * @param options The options to set
   */
  private setDefaultOptions(options: NatsConnectionOptions){
    //If server binding options sat set the options
    options.encoding = 'utf8';
    options.payload = Payload.BINARY;
    return options;
  }

  {%- for channelName, channel in asyncapi.channels() %}

  {%- if channel | isRequestReply %}
    {%- if channel | isRequester %}
  /**
  *  Wrapper
  * @param requestMessage The request message to send.
  */
  public {{channelName | camelCase }}Request(requestMessage: {{ channel.publish().message(0).uid() | pascalCase }}Message): Promise<{{ channel.subscribe().message(0).uid() | pascalCase }}Message> {
    return {{ channelName | camelCase }}Channel.request(requestMessage, this.nc);
  }
    {%- endif %}
    {%- if channel | isReplier %}
  /**
  *  Wrapper
  * @param onRequest Called when request recieved.
  * @param onReplyError Called when it was not possible to send the reply.
  */
  public {{channelName | camelCase }}Reply(onRequest : (err?: NatsError, msg?: {{ channel.subscribe().message(0).uid() | pascalCase }}Message) => {{ channel.publish().message(0).uid() | pascalCase }}Message, onReplyError : (err: NatsError) => void): Promise<Subscription> {
    return {{ channelName | camelCase }}Channel.reply(onRequest, onReplyError, this.nc);
  }
    {%- endif %}
  {%- endif %}

  {%- if channel | isPubsub %}
    {%- if channel.hasSubscribe() %}
  /**
    *  Wrapper
    * @param onDataCallback Called when message recieved.
    */
  public {{channelName | camelCase }}Subscribe(onDataCallback : (err?: NatsError, msg?: {{ channel.subscribe().message(0).uid() | pascalCase }}Message) => void): Promise<Subscription> {
    return {{ channelName | camelCase }}Channel.subscribe(onDataCallback, this.nc);
  }
    {%- endif %}
    {%- if channel.hasPublish() %}
  /**
  *  Wrapper for
  * @param requestMessage The message to publish.
  */
  public {{channelName | camelCase }}(requestMessage: {{ channel.publish().message(0).uid() | pascalCase }}Message): Promise<void> {
    return {{ channelName | camelCase }}Channel.publish(requestMessage, this.nc);
  }
    {%- endif %}
  {%- endif %}

  {%- endfor %}



}
